package config

import (
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	yaml "gopkg.in/yaml.v2"
)

// Config for p4metrics - see SampleConfig for details
type Config struct {
	MetricsRoot          string        `yaml:"metrics_root"`
	SDPInstance          string        `yaml:"sdp_instance"` // If this is set then it defines the other variables such as P4Port
	P4Port               string        `yaml:"p4port"`       // P4PORT value (if not set in env or as parameter)
	P4User               string        `yaml:"p4user"`       // ditto
	P4Config             string        `yaml:"p4config"`     // P4CONFIG file - useful if non-SDP
	P4Bin                string        `yaml:"p4bin"`        // Only useful if non SDP - path to "p4" binary if not in $PATH
	P4DBin               string        `yaml:"p4dbin"`       // Only useful if non SDP - path to "p4d" binary if not in $PATH
	UpdateInterval       time.Duration `yaml:"update_interval"`
	LongUpdateInterval   time.Duration `yaml:"long_update_interval"`
	MonitorSwarm         bool          `yaml:"monitor_swarm"`
	SwarmURL             string        `yaml:"swarm_url"`    // Swarm URL - if the value returned by p4 property -l does not work (VPN etc)
	SwarmSecure          bool          `yaml:"swarm_secure"` // Wehther to validate the Swarm HTTPS certificate
	CmdsByUser           bool          `yaml:"cmds_by_user"`
	MaxJournalSize       string        `yaml:"max_journal_size"`    // Maximum size of journal file to monitor, e.g. 100M, 0 means no limit
	MaxJournalPercent    string        `yaml:"max_journal_percent"` // Maximum size of journal as percentage of total P4LOGS disk space, e.g. 40, 0 means no limit
	MaxLogSize           string        `yaml:"max_log_size"`        // Maximum size of journal file to monitor, e.g. 100M, 0 means no limit
	MaxLogPercent        string        `yaml:"max_log_percent"`     // Maximum size of log as percentage of total P4LOGS disk space, e.g. 40, 0 means no limit
	MaxJournalSizeInt    int64
	MaxJournalPercentInt int
	MaxLogSizeInt        int64
	MaxLogPercentInt     int
}

// SampleConfig shows a sample config file - this can be used as a template
// for creating your own config file and is also output if you run p4metrics
// with the --sample.config flag.
const SampleConfig = `
# Sample p4metrics configuration file - normally called p4metrics.yaml
# Generated by: p4metrics --sample.config
# Edit as required - see comments below
# Blank lines and lines starting with # are comments and ignored

# ----------------------
# metrics_root: REQUIRED! Directory into which to write metrics files for processing by node_exporter.
# Ensure that node_exporter user has read access to this folder (and any parent directories)!
metrics_root: /hxlogs/metrics

# ----------------------
# sdp_instance: SDP instance - typically integer, but can be alphanumeric
# See: https://swarm.workshop.perforce.com/projects/perforce-software-sdp for more
# If this value is blank then it is assumed to be a non-SDP instance, and you will want
# to set other values with a prefix of p4 below.
sdp_instance:

# ----------------------
# p4port: The value of P4PORT to use
# IGNORED if sdp_instance is non-blank!
p4port:

# ----------------------
# p4user: The value of P4USER to use
# IGNORED if sdp_instance is non-blank!
p4user:

# ----------------------
# p4config: The value of a P4CONFIG to use
# This is very useful and should be set to an absolute path if you need values like P4TRUST/P4TICKETS etc
# IGNORED if sdp_instance is non-blank!
p4config:      

# ----------------------
# p4bin: The absolute path to the p4 binary to be used - important if not available in your PATH
# E.g. /some/path/to/p4
# IGNORED if sdp_instance is non-blank! (Will use /p4/<instance>/bin/p4_<instance>)
p4bin:      p4

# ----------------------
# p4dbin: The absolute path to the p4d binary to be used - important if not available in your PATH
# E.g. /some/path/to/p4d
# IGNORED if sdp_instance is non-blank! (Will use /p4/<instance>/bin/p4d_<instance>)
p4dbin:     p4d

# ----------------------
# update_interval: how frequently metrics should be written - defaults to 1m
# Values are as parsed by Go, e.g. 1m or 30s etc.
update_interval:    1m

# ----------------------
# cmds_by_user: true/false - Whether to output metrics p4_monitor_by_user
# Normally this should be set to true as the metrics are useful.
# If you have a p4d instance with hundreds/thousands of users you may find the number
# of metrics labels is too great (one per distinct user), so set this to false.
# Or set it to false if any personal information concerns
cmds_by_user:   true

# ----------------------
# monitor_swarm: true/false - Whether to monitor status and version of swarm
# Normally this should be set to true - won't run if there is no Swarm property
monitor_swarm:   true

# ----------------------
# swarm_url: URL of the Swarm instance to monitor
# Normally this is blank, and p4metrics reads the p4 property value
# Sometimes (e.g. due to VPN setup) that value is not correct - so set this instead
# swarm_url: https://swarm.example.com
swarm_url:

# ----------------------
# swarm_secure: true/false - Whether to validate SSL for swarm
# Defaults to true, but if you have a self-signed certificate or similar set to false
swarm_secure: true

# ----------------------
# max_journal_size: Maximum size of journal file to monitor, e.g. 10G, 0 means no limit
# Units are K/M/G/T/P (powers of 1024), e.g. 10M, 1.5G etc
# If the journal file is larger than this value it will be rotated using: p4 admin journal
# This is useful to avoid sudden large journal growth causing disk space issues (often a sign of automation problems).
# Note that this is only actioned if the p4d server is a "standard" or "commit-server" (so no replicas or edge servers).
# The system will only rotate the journal if the user is a super user and the journalPrefix volume has sufficient free space.
# Leave blank or set to 0 to disable (see max_journal_percent below for alternative).
max_journal_size:

# ----------------------
# max_journal_percent: Maximum size of journal as percentage of total P4LOGS disk space, e.g. 40, 0 means no limit
# Values are integers 0-99
# Volume information is read using: p4 diskspace
# If the journal file is larger than this percentag value it will be rotated using: p4 admin journal
# This is useful to avoid sudden large journal growth causing disk space issues (often a sign of automation problems).
# Note that this is only actioned if the p4d server is a "standard" or "commit-server" (so no replicas or edge servers).
# The system will only rotate the journal if the journalPrefix volume has sufficient free space.
# Leave blank or set to 0 to disable (see max_journal_size above for alternative).
max_journal_percent:     30

# ----------------------
# max_log_size: Maximum size of P4LOG file to monitor - similar to max_journal_size above
# Units are K/M/G/T/P (powers of 1024), e.g. 10M, 1.5G etc
# If the log file is larger than this value it will be rotated and compressed (using rename + gzip)
max_log_size:

# ----------------------
# max_log_percent: Maximum size of log as percentage of total P4LOGS disk space, e.g. 40, 0 means no limit
# Values are integers 0-99
# Volume information is read using: p4 diskspace
# If the log file is larger than this percentage value it will be rotated and compressed (using rename + gzip)
max_log_percent:        30

`

func ConvertToBytes(size string) (int64, error) {
	if len(size) == 0 {
		return 0, nil
	}
	// Find the numeric part and unit
	numStr := size
	var unit string
	for i, char := range size {
		if !strings.ContainsRune("0123456789.", char) {
			numStr = size[:i]
			unit = strings.ToUpper(size[i:])
			break
		}
	}
	// Parse the numeric part
	num, err := strconv.ParseFloat(numStr, 64)
	if err != nil {
		return 0, fmt.Errorf("invalid number format: %v", err)
	}
	// Convert based on unit
	var multiplier uint64
	switch unit {
	case "B", "":
		multiplier = 1
	case "K":
		multiplier = 1024
	case "M":
		multiplier = 1024 * 1024
	case "G":
		multiplier = 1024 * 1024 * 1024
	case "T":
		multiplier = 1024 * 1024 * 1024 * 1024
	case "P":
		multiplier = 1024 * 1024 * 1024 * 1024 * 1024
	default:
		return 0, fmt.Errorf("unsupported unit: %s", unit)
	}
	return int64(num * float64(multiplier)), nil
}

// Unmarshal the config
func Unmarshal(config []byte) (*Config, error) {
	// Default values specified here
	cfg := &Config{
		UpdateInterval: 60 * time.Second,
		MonitorSwarm:   false,
		SwarmSecure:    true}
	err := yaml.Unmarshal(config, cfg)
	if err != nil {
		return nil, fmt.Errorf("invalid configuration: %v. make sure to use 'single quotes' around strings with special characters (like match patterns or label templates), and make sure to use '-' only for lists (metrics) but not for maps (labels)", err.Error())
	}
	err = cfg.validate()
	if err != nil {
		return nil, err
	}
	return cfg, nil
}

// LoadConfigFile - loads p4prometheus config file
func LoadConfigFile(filename string) (*Config, error) {
	content, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to load %v: %v", filename, err.Error())
	}
	cfg, err := LoadConfigString(content)
	if err != nil {
		return nil, fmt.Errorf("failed to load %v: %v", filename, err.Error())
	}
	// Set defaults
	if cfg.P4Bin == "" {
		cfg.P4Bin = "p4"
	}
	if cfg.P4DBin == "" {
		cfg.P4DBin = "p4d"
	}
	return cfg, nil
}

// LoadConfigString - loads a string
func LoadConfigString(content []byte) (*Config, error) {
	cfg, err := Unmarshal([]byte(content))
	return cfg, err
}

func (c *Config) validate() error {
	if c.MetricsRoot == "" {
		return fmt.Errorf("invalid metrics_root: please specify directory to which p4metrics *.prom files should be written, e.g. /hxlogs/metrics")
	}
	var err error
	if c.MaxJournalSize != "" && c.MaxJournalSize != "0" {
		if c.MaxJournalSizeInt, err = ConvertToBytes(c.MaxJournalSize); err != nil {
			return fmt.Errorf("invalid max_journal_size: %q please specify valid size, e.g. 10.5M (options: K/M/G/T/P), 0 means no limit: %v", c.MaxJournalSize, err)
		}
	}
	if c.MaxLogSize != "" && c.MaxLogSize != "0" {
		if c.MaxLogSizeInt, err = ConvertToBytes(c.MaxLogSize); err != nil {
			return fmt.Errorf("invalid max_log_size: %q please specify valid size, e.g. 10.5M (options: K/M/G/T/P), 0 means no limit: %v", c.MaxLogSize, err)
		}
	}
	if c.MaxJournalPercent != "" && c.MaxJournalPercent != "0" {
		var val int64
		if val, err = ConvertToBytes(c.MaxJournalPercent); err != nil {
			return fmt.Errorf("invalid max_journal_percent: %q please specify valid percent as integer 0-99, 0 means no limit: %v", c.MaxJournalPercent, err)
		}
		if val < 0 || val > 99 {
			return fmt.Errorf("invalid max_journal_percent: %q please specify valid percent in range 0-99", c.MaxJournalPercent)
		}
		c.MaxJournalPercentInt = int(val)
	}
	if c.MaxLogPercent != "" && c.MaxLogPercent != "0" {
		var val int64
		if val, err = ConvertToBytes(c.MaxLogPercent); err != nil {
			return fmt.Errorf("invalid max_log_percent: %q please specify valid percent as integer 0-99, 0 means no limit: %v", c.MaxLogPercent, err)
		}
		if val < 0 || val > 99 {
			return fmt.Errorf("invalid max_log_percent: %q please specify valid percent in range 0-99", c.MaxLogPercent)
		}
		c.MaxLogPercentInt = int(val)
	}
	return nil
}
